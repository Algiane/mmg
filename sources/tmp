/* attempt to put points on geometry */
static int updgeo(pMesh mesh,pSol met) {
  pTetra    pt;
  xTetra   *pxt;
  int       k;
  char      i;
  
  for (k=1; k<=mesh->ne; k++) {
    pt = &mesh->tetra[k];
    if ( !MG_EOK(pt) || MG_SIN(pt->tag) )  continue;
  
    pxt = &mesh->xtetra[pt->xt];
    for (i=0; i<4; i++) {
    
    //if ( pxt->ftag[i] & MG_BDY )  chkedg(mesh,k,i);
    }
  }
  
  return(1);
}

/* Simulate at the same time creation and bulging of one point, with new position o, 
 to be inserted at an edge, whose shell is passed : 
 return 0 if final position is invalid, 1 if all checks are ok */
int simbulgept(pMesh mesh, int *list, int ilist, double o[3]){
  pTetra         pt,pt0;
  pPoint         ppt0;
  int            k,iel;
  unsigned char  ie,ia,ib;
  
  pt0 = &mesh->tetra[0];
  
  ppt0 = &mesh->point[0];
  ppt0->c[0] = o[0];
  ppt0->c[1] = o[1];
  ppt0->c[2] = o[2];
  
  for(k=0;k<ilist;k++){
    iel = list[k] / 6;
  ie  = list[k] % 6; 
  
  ia = iare[ie][0];
  ib = iare[ie][1];
  
  pt = &mesh->tetra[iel];
  memcpy(pt0,pt,sizeof(Tetra));
  
  pt0->v[ia] = 0;
  
  if(orcal(mesh,0) < EPSD)
    return(0);

  memcpy(pt0,pt,sizeof(Tetra)); 

  pt0->v[ib] = 0; 

  if(orcal(mesh,0) < EPSD)
    return(0);
    
  }
  
  return(1);
}

static int adptetra(pMesh mesh, pSol met){
  pTetra        pt;
  pxTetra       pxt;
  pPoint        p0,p1;
  int           k,it,nnc,maxit,list[LMAX+2],ilist,nc,nprop;
  double        len;
  unsigned char i,j,ia,indp,indq,edtag,acc;

  if ( abs(info.imprim) > 4 || info.ddebug )
    fprintf(stdout,"  ** ADAPTING MESH\n");  
  
  /* Iterative mesh modifications */  
  it = nnc = 0;
  maxit = 20;
  
  nprop = 0;
  do{
    nc = 0;
    for(k=1;k<=mesh->ne;k++){
      pt = &mesh->tetra[k];
    if ( !MG_EOK(pt) || pt->ref < 0 )   continue;
    
    if(pt->xt) 
      pxt = &mesh->xtetra[pt->xt];
    
    for(i=0;i<4;i++){
      /* Case of a boundary face */
      if(pt->xt && (pxt->ftag[i] & MG_BDY)){
      for(j=0;j<3;j++){
        ia = iarf[i][j];
      indp = iare[ia][0];
      indq = iare[ia][1]; // iare[ia][0] is collapsed on q

      p0 = &mesh->point[pt->v[indp]];
      p1 = &mesh->point[pt->v[indq]];
            
      if( MG_SIN(pxt->tag[ia])) continue;
      if ( (p0->tag > p1->tag)) continue; 
      edtag = (pxt->tag[ia] |= MG_BDY);   
      if(p0->tag > edtag)   continue;

      len = lenedg(mesh,pt->v[indp],pt->v[indq]);  //update

      if(len < LSHRT){
          ilist = chkcolbdy(mesh,k,i,j,list);
        if(ilist){
        nprop++;
        printf("Collapse de %d vers %d \n ",pt->v[indp],pt->v[indq]);
          acc = colver(mesh,list,ilist,indq);
        //nc += colver(mesh,list,ilist,indq);
                if(acc) chkmsh(mesh,0,0);           
        break;
        }
      }
      }
    }
    /* Case of an internal face */
    else{
      for(j=0;j<3;j++){
        ia = iarf[i][j];
      indp = iare[ia][0];
      indq = iare[ia][1]; // p is collapsed on q
      p0 = &mesh->point[pt->v[indp]];
      p1 = &mesh->point[pt->v[indq]];
            
      /* Only way to collapse a bdy point is on another bdy point : case handled before */
      if(p0->tag & MG_BDY)
             continue;
       
      else if ( p0->tag > p1->tag ) continue;
       
      len = lenedg(mesh,pt->v[indp],pt->v[indq]);  //update

      if(len < LSHRT){
          ilist = chkcolint(mesh,k,i,j,list);
        if(ilist){
          //continue;
        printf("Collapse de %d vers %d \n ",pt->v[indp],pt->v[indq]);
        //printf("ilist = %d\n",ilist);
          nprop++;
        acc = colver(mesh,list,ilist,indq);
                //nc += colver(mesh,list,ilist,indq);
        //printf("nc = %d \n",nc);
        if(acc) chkmsh(mesh,0,0);
        break;
        }
      }
      }
    }
    }
    
  }
  
  nnc += nc;
  }
  while( nc > 0 && ++it < maxit );

  if ( abs(info.imprim) > 4 && nnc > 0 )
    fprintf(stdout,"     total: %d collapsed \n",nnc);
  
  printf("On a propose : %d \n",nprop);
  return(1);
}

/* Analyze tetrahedra and move points so as to make mesh more uniform */
static int movetetra(pMesh mesh){
  pTetra          pt;
  pPoint          ppt;
  pxTetra         pxt;
  double          *n;
  int             i,k,nmv,nmb,nmr,nmref,lists[LMAX+2],listv[LMAX+2],ilists,ilistv,it;
  unsigned char   j,i0,base;
  
  if ( abs(info.imprim) > 4 || info.ddebug )
    fprintf(stdout,"  ** OPTIMIZING MESH\n");
  
  it = 0; 

  for (k=1; k<=mesh->np; k++)
  mesh->point[k].flag = 0;

  nmv = 0;
  nmb = 0;
  nmr = 0;
  nmref = 0;

  base = ++mesh->base;

  do{
    base++;
    for( k=1 ; k<= mesh->ne ; k++ ){
      pt = &mesh->tetra[k];
    if ( !MG_EOK(pt) || pt->ref < 0 )   continue;
  
    for (i=0; i<4; i++) {
      for(j=0;j<3;j++){
        i0 = idir[i][j];  // point j on face i
        ppt = &mesh->point[pt->v[i0]];
        if ( ppt->flag == base )  continue;
        
      if( MG_BDY & ppt->tag ){
      pxt = &mesh->xtetra[pt->xt];
      if(!(MG_BDY & pxt->ftag[i])) continue; // Catch a boundary point by a boundary face
        if(MG_SIN(ppt->tag)) continue;
      else if(MG_GEO & ppt->tag){
        if(!boulesurfvolp(mesh,k,i0,i,listv,&ilistv,lists,&ilists)) continue;
        nmr += movbdyridpt(mesh,listv,ilistv,lists,ilists);
      }
      else if(MG_REF & ppt->tag){
        if(!boulesurfvolp(mesh,k,i0,i,listv,&ilistv,lists,&ilists)) continue;
        nmref += movbdyrefpt(mesh,listv,ilistv,lists,ilists);
      }
      else{ 
        if(!boulesurfvolp(mesh,k,i0,i,listv,&ilistv,lists,&ilists)) continue;
        n = &(mesh->xpoint[ppt->xp].n1[0]);
        if(!directsurfball(mesh, pt->v[i0],lists,ilists,n)) continue;
          nmb += movbdyregpt(mesh,listv,ilistv,lists,ilists);
      }
      ppt->flag = base;

        }
      
      else{
            if(ppt->xp){
        printf("ppt->xp %d \n",ppt->xp);
        saveMesh(mesh);
        exit(0);
      }
      
      ilistv = boulevolp(mesh,k,i0,listv);
      if(!ilistv) continue;
      nmv += movintpt(mesh,listv,ilistv);
      ppt->flag = base;
      }
      }       
    }
    }
  }
  while( ++it < 10 );
  
  if ( abs(info.imprim) > 4 )
    fprintf(stdout,"     total: %d boundary points moved  (%d ridge, %d ref) \
                     %d internal points moved \n",nmb+nmr+nmref,nmr, nmref, nmv);
  
  return(1);  

}

