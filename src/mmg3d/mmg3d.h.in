/* =============================================================================
**  This file is part of the MMG3D 5 software package for the tetrahedral
**  mesh modification.
**  Copyright (c) Inria - IMB (Universit√© de Bordeaux) - LJLL (UPMC), 2004- .
**
**  MMG3D 5 is free software: you can redistribute it and/or modify it
**  under the terms of the GNU Lesser General Public License as published
**  by the Free Software Foundation, either version 3 of the License, or
**  (at your option) any later version.
**
**  MMG3D 5 is distributed in the hope that it will be useful, but WITHOUT
**  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
**  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
**  License for more details.
**
**  You should have received a copy of the GNU Lesser General Public
**  License and of the GNU General Public License along with MMG3D 5 (in
**  files COPYING.LESSER and COPYING). If not, see
**  <http://www.gnu.org/licenses/>. Please read their terms carefully and
**  use this copy of the MMG3D 5 distribution only if you accept them.
** =============================================================================
*/

#ifndef _MMG3D_H
#define _MMG3D_H

/* Warning: never ever use assert() with a function,
   the option -DNDEBUG suppress all assert()*/
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <signal.h>
#include <ctype.h>
#include <float.h>
#include <math.h>
#if (defined(__APPLE__) && defined(__MACH__))
#include <sys/sysctl.h>
#elif defined(__unix__) || defined(__unix) || defined(unix)
#include <unistd.h>
#endif

#include "mmg3d5_redefine.h"
#include "libmmg3d5.h"

#define MG_VER   "@CMAKE_RELEASE_VERSION@"" c"
#define MG_REL   "@CMAKE_RELEASE_DATE@"
#define MG_CPY   "Copyright (c) IMB-LJLL, 2004-"
#define MG_STR   "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"

/* Macros */
#define MG_MAX(a,b) (((a) > (b)) ? (a) : (b))
#define MG_MIN(a,b) (((a) < (b)) ? (a) : (b))

#define MG_SMSGN(a,b)  (((double)(a)*(double)(b) > (0.0)) ? (1) : (0))

/** Free allocated pointers of mesh and sol structure and return value val */
#ifdef SINGUL
#define _MMG5_RETURN_AND_FREE(mesh,met,sing,val)do  \
    {                                               \
        MMG5_Free_all(mesh,met,sing);               \
        return(val);                                \
    }while(0)
#else
#define _MMG5_RETURN_AND_FREE(mesh,met,sing,val)do  \
    {                                               \
        MMG5_Free_all(mesh,met);                    \
        return(val);                                \
    }while(0)
#endif

/** Error message when lack of memory */
#define _MMG5_INCREASE_MEM_MESSAGE() do                         \
    {                                                           \
        printf("  ## Check the mesh size or increase maximal"); \
        printf(" authorized memory with the -m option.\n");     \
    } while(0)

/** Check if used memory overflow maximal authorized memory.
    Execute the command law if lack of memory. */
#define _MMG5_CHK_MEM(mesh,size,string,law) do                          \
    {                                                                   \
        if ( ((mesh)->memCur) > ((mesh)->memMax) ||                     \
             ((mesh)->memCur < 0 )) {                                   \
            fprintf(stdout,"  ## Error:");                              \
            fprintf(stdout," unable to allocate %s.\n",string);         \
            fprintf(stdout,"  ## Check the mesh size or ");             \
            fprintf(stdout,"increase maximal authorized memory with the -m option.\n"); \
            (mesh)->memCur -= (long long)(size);                        \
            law;                                                        \
        }                                                               \
    }while(0)

/** Free pointer ptr of mesh structure and compute the new used memory.
    size is the size of the pointer */
#define _MMG5_DEL_MEM(mesh,ptr,size) do         \
    {                                           \
        (mesh)->memCur -= (long long)(size);    \
        free(ptr);                              \
        ptr = NULL;                             \
    }while(0)

/** Increment memory counter memCur and check if we don't overflow
    the maximum authorizied memory memMax. */
#define _MMG5_ADD_MEM(mesh,size,message,law) do \
    {                                           \
        (mesh)->memCur += (long long)(size);    \
        _MMG5_CHK_MEM(mesh,size,message,law);   \
    }while(0)

/** Safe deallocation */
#define _MMG5_SAFE_FREE(ptr) do                 \
    {                                           \
        free(ptr);                              \
        ptr = NULL;                             \
    }while(0)


/** Safe allocation with calloc */
#define _MMG5_SAFE_CALLOC(ptr,size,type) do             \
    {                                                   \
        ptr = (type *)calloc((size),sizeof(type));      \
        if ( !ptr ) {                                   \
            perror("  ## Memory problem: calloc");      \
            exit(EXIT_FAILURE);                         \
        }                                               \
    }while(0)

/** Safe allocation with malloc */
#define _MMG5_SAFE_MALLOC(ptr,size,type) do             \
    {                                                   \
        ptr = (type *)malloc((size)*sizeof(type));      \
        if ( !ptr ) {                                   \
            perror("  ## Memory problem: malloc");      \
            exit(EXIT_FAILURE);                         \
        }                                               \
    }while(0)

/** Safe reallocation */
#define _MMG5_SAFE_REALLOC(ptr,size,type,message) do            \
    {                                                           \
        type* tmp;                                              \
        tmp = (type *)realloc((ptr),(size)*sizeof(type));       \
        if ( !tmp ) {                                           \
            _MMG5_SAFE_FREE(ptr);                               \
            perror(" ## Memory problem: realloc");              \
            exit(EXIT_FAILURE);                                 \
        }                                                       \
                                                                \
        if ( abs(mesh->info.imprim) > 6 || mesh->info.ddebug )  \
            fprintf(stdout,                                     \
                    "  ## Warning: %s:%d: %s reallocation.\n",  \
                    __FILE__,__LINE__,message);                 \
                                                                \
                                                                \
        (ptr) = tmp;                                            \
    }while(0)

/** safe reallocation with memset at 0 for the new values of tab */
#define _MMG5_SAFE_RECALLOC(ptr,prevSize,newSize,type,message) do   \
    {                                                               \
        type* tmp;                                                  \
        int k;                                                      \
                                                                    \
        tmp = (type *)realloc((ptr),(newSize)*sizeof(type));        \
        if ( !tmp ) {                                               \
            _MMG5_SAFE_FREE(ptr);                                   \
            perror(" ## Memory problem: realloc");                  \
            exit(EXIT_FAILURE);                                     \
        }                                                           \
                                                                    \
        if ( abs(mesh->info.imprim) > 6 || mesh->info.ddebug )      \
            fprintf(stdout,                                         \
                    "  ## Warning: %s:%d: %s reallocation.\n",      \
                    __FILE__,__LINE__,message);                     \
                                                                    \
        (ptr) = tmp;                                                \
        for ( k=prevSize; k<newSize; k++) {                         \
            memset(&ptr[k],0,sizeof(type));                         \
        }                                                           \
    }while(0)

/** Reallocation of ptr of type type at size (initSize+wantedGap*initSize)
    if possible or at maximum available size if not. Execute the command law
    if reallocation failed. Memset to 0 for the new values of table. */
#define _MMG5_TAB_RECALLOC(mesh,ptr,initSize,wantedGap,type,message,law) do \
    {                                                                   \
        int gap;                                                        \
                                                                        \
        if ( (mesh->memMax-mesh->memCur) <                              \
             (long long) (wantedGap*initSize*sizeof(type)) ) {          \
            gap = (int)(mesh->memMax-mesh->memCur)/sizeof(type);        \
            if(gap<1) {                                                 \
                fprintf(stdout,"  ## Error:");                          \
                fprintf(stdout," unable to allocate %s.\n",message);    \
                fprintf(stdout,"  ## Check the mesh size or ");         \
                fprintf(stdout,"increase maximal authorized memory with the -m option.\n"); \
                law;                                                    \
            }                                                           \
        }                                                               \
        else                                                            \
            gap = wantedGap*initSize;                                   \
                                                                        \
        _MMG5_ADD_MEM(mesh,gap*sizeof(type),message,law);               \
        _MMG5_SAFE_RECALLOC((ptr),initSize+1,initSize+gap+1,type,message); \
        initSize = initSize+gap;                                        \
    }while(0);


/** Reallocation of point table and sol table and creation
    of point ip with coordinates o and tag tag*/
#define _MMG5_POINT_REALLOC(mesh,sol,ip,wantedGap,law,o,tag ) do        \
    {                                                                   \
        int klink;                                                      \
                                                                        \
        _MMG5_TAB_RECALLOC(mesh,mesh->point,mesh->npmax,wantedGap,Point, \
                     "larger point table",law);                         \
                                                                        \
        mesh->npnil = mesh->np+1;                                       \
        for (klink=mesh->npnil; klink<mesh->npmax-1; klink++)           \
            mesh->point[klink].tmp  = klink+1;                          \
                                                                        \
        /* solution */                                                  \
        if ( sol->m ) {                                                 \
            _MMG5_ADD_MEM(mesh,(mesh->npmax-sol->npmax)*sizeof(double), \
                    "larger solution",law);                             \
            _MMG5_SAFE_REALLOC(sol->m,mesh->npmax+1,double,"larger solution"); \
        }                                                               \
        sol->npmax = mesh->npmax;                                       \
                                                                        \
        /* We try again to add the point */                             \
        ip = newPt(mesh,o,tag);                                         \
        if ( !ip ) {law;}                                               \
    }while(0)

/** Reallocation of point table, sol table and bucket table and creation
    of point ip with coordinates o and tag tag*/
#define _MMG5_POINT_AND_BUCKET_REALLOC(mesh,sol,ip,wantedGap,law,o,tag ) do \
    {                                                                   \
        int klink,gap;                                                  \
                                                                        \
        if ( (mesh->memMax-mesh->memCur) <                              \
             (long long) (wantedGap*mesh->npmax*                        \
                          (sizeof(Point)+sizeof(int))) ) {              \
            gap = (int)(mesh->memMax-mesh->memCur)/                     \
                (sizeof(Point)+sizeof(int));                            \
            if(gap < 1) {                                               \
                fprintf(stdout,"  ## Error:");                          \
                fprintf(stdout," unable to allocate %s.\n","larger point/bucket table"); \
                fprintf(stdout,"  ## Check the mesh size or ");         \
                fprintf(stdout,"increase maximal authorized memory with the -m option.\n"); \
                law;                                                    \
            }                                                           \
        }                                                               \
        else                                                            \
            gap = (int)(wantedGap*mesh->npmax);                         \
                                                                        \
        _MMG5_ADD_MEM(mesh,gap*(sizeof(Point)+sizeof(int)),             \
                "point and bucket",law);                                \
        _MMG5_SAFE_RECALLOC(mesh->point,mesh->npmax+1,                  \
                      mesh->npmax+gap+1,Point,"larger point table");    \
        _MMG5_SAFE_RECALLOC(bucket->link,mesh->npmax+1,                 \
                      mesh->npmax+gap+1,int,"larger bucket table");     \
        mesh->npmax = mesh->npmax+gap;                                  \
                                                                        \
        mesh->npnil = mesh->np+1;                                       \
        for (klink=mesh->npnil; klink<mesh->npmax-1; klink++)           \
            mesh->point[klink].tmp  = klink+1;                          \
                                                                        \
        /* solution */                                                  \
        if ( sol->m ) {                                                 \
            _MMG5_ADD_MEM(mesh,(mesh->npmax-sol->npmax)*sizeof(double), \
                    "larger solution",law);                             \
            _MMG5_SAFE_REALLOC(sol->m,mesh->npmax+1,double,"larger solution"); \
        }                                                               \
        sol->npmax = mesh->npmax;                                       \
                                                                        \
        /* We try again to add the point */                             \
        ip = newPt(mesh,o,tag);                                         \
        if ( !ip ) {law;}                                               \
    }while(0)

/** Reallocation of tetra table and creation
    of tetra jel */
#define _MMG5_TETRA_REALLOC(mesh,jel,wantedGap,law ) do                 \
    {                                                                   \
        int klink,oldSiz;                                               \
                                                                        \
        oldSiz = mesh->nemax;                                           \
        _MMG5_TAB_RECALLOC(mesh,mesh->tetra,mesh->nemax,wantedGap,Tetra, \
                     "larger tetra table",law);                         \
                                                                        \
        mesh->nenil = mesh->ne+1;                                       \
        for (klink=mesh->nenil; klink<mesh->nemax-1; klink++)           \
            mesh->tetra[klink].v[3]  = klink+1;                         \
                                                                        \
        if ( mesh->adja ) {                                             \
            /* adja table */                                            \
            _MMG5_ADD_MEM(mesh,4*(mesh->nemax-oldSiz)*sizeof(int),      \
                          "larger adja table",law);                     \
            _MMG5_SAFE_RECALLOC(mesh->adja,4*mesh->ne+5,4*mesh->nemax+5,int \
                                ,"larger adja table");                  \
        }                                                               \
                                                                        \
        /* We try again to add the point */                             \
        jel = newElt(mesh);                                             \
        if ( !jel ) {law;}                                              \
    }while(0)

/* numerical accuracy */
#define _MMG5_ALPHAD    20.7846096908265    //0.04811252243247      /* 12*sqrt(3) */
#define _MMG5_LLONG     2.5//2.0   // 1.414213562373
#define _MMG5_LSHRT     0.3  // 0.707106781186
#define _MMG5_LOPTL     1.3
#define _MMG5_LOPTS     0.6
#define _MMG5_ANGEDG    0.707106781186548   /*0.573576436351046 */
#define _MMG5_ANGLIM   -0.999999
#define _MMG5_SQR32     0.866025403784
#define _MMG5_ATHIRD    0.333333333333
#define _MMG5_EPSD      1.e-30
#define _MMG5_EPSD2     1.0e-200
#define _MMG5_EPS       1.e-06
#define _MMG5_LMAX      10240
#define _MMG5_BADKAL    0.2
#define _MMG5_NULKAL    1.e-30
#ifdef SINGUL
#define _MMG5_EPS2      1.e-12
#endif

#define _MMG5_NPMAX  1000000 //200000
#define _MMG5_NAMAX   200000 //40000
#define _MMG5_NTMAX  2000000 //400000
#define _MMG5_NEMAX  6000000 //1200000

#define _MMG5_MEMMAX  800 //160
#define _MMG5_BOXSIZE 500

#ifndef M_PI
#define M_PI            3.14159265358979323846   /**< pi   */
#define M_PI_2          1.57079632679489661923   /**< pi/2 */
#endif

/* tags */
#define  MG_NOTAG     (0)
#define  MG_REF       (1 << 0)        /**< 1  edge reference  */
#define  MG_GEO       (1 << 1)        /**< 2  geometric ridge */
#define  MG_REQ       (1 << 2)        /**< 4  required entity */
#define  MG_NOM       (1 << 3)        /**< 8  non manifold    */
#define  MG_BDY       (1 << 4)        /**< 16  boundary entity */
#define  MG_CRN       (1 << 5)        /**< 32  corner         */
#define  MG_NUL       (1 << 6)        /**< 64  vertex removed */
#ifdef SINGUL
#define  MG_SGL       (1 << 7)        /**< 128 inserted singularity */
#endif

#define MG_PLUS    2
#define MG_MINUS   3
#define MG_ISO    10

#define MG_VOK(ppt)      (ppt && ((ppt)->tag < MG_NUL)) /**< Vertex OK */
#define MG_EOK(pt)       (pt && ((pt)->v[0] > 0))       /**< Element OK */
#define MG_EDG(tag)      ((tag & MG_GEO) || (tag & MG_REF)) /**< Edge or Ridge */
#define MG_SIN(tag)      ((tag & MG_CRN) || (tag & MG_REQ)) /**< Corner or Required */

#define MG_SET(flag,bit) ((flag) |= (1 << (bit)))  /**< bit number bit is set to 1 */
#define MG_CLR(flag,bit) ((flag) &= ~(1 << (bit))) /**< bit number bit is set to 0 */
#define MG_GET(flag,bit) ((flag) & (1 << (bit)))   /**< return bit number bit value */

extern unsigned char _MMG5_inxt2[3];   /**< next vertex of triangle: {1,2,0} */
extern unsigned char _MMG5_iprv2[3];   /**< previous vertex of triangle: {2,0,1} */
extern unsigned char _MMG5_inxt3[7];   /**< next vertex of tetra: {1,2,3,0,1,2,3} */
extern unsigned char _MMG5_iprv3[7];   /**< previous vertex of tetra: {3,0,1,2,3,0,1} */
extern unsigned char _MMG5_idir[4][3]; /**< idir[i] : vertices of face opposite to vertex i */
extern          char _MMG5_idirinv[4][4]; /**< idirinv[i][j] : num of the jth point in the ith face */
extern unsigned char _MMG5_iarf[4][3]; /**< iarf[i]: edges of face opposite to vertex i */
extern unsigned char _MMG5_iarfinv[4][6]; /**< num of the j^th edge in the i^th face */
extern unsigned char _MMG5_iare[6][2]; /**< vertices of extremities of the edges of the tetra */
extern unsigned char _MMG5_ifar[6][2]; /**< ifar[i][]: faces sharing the ith edge of the tetra */
extern unsigned char _MMG5_isar[6][2]; /**< isar[i][]: vertices of extremities of the edge opposite to the ith edge */
extern unsigned char _MMG5_arpt[4][3]; /**< arpt[i]: edges passing through vertex i */


typedef struct {
    double  b[10][3]; /**< Bezier basis functions */
    double  n[6][3],t[6][3]; /**< normals and tangents at points */
    pPoint  p[3];
} _MMG5_Bezier;
typedef _MMG5_Bezier * _MMG5_pBezier;

/** used to hash edges */
typedef struct {
    int   a,b,nxt;
    int   s,k; /** k = point along edge a b */
} _MMG5_hedge;

typedef struct {
    int     siz,max,nxt;
    _MMG5_hedge  *item;
} _MMG5_Hash;

typedef struct {
    int     size;
    int    *head;
    int    *link;
} _MMG5_Bucket;
typedef _MMG5_Bucket * _MMG5_pBucket;

#ifdef SINGUL
typedef struct {
    double   c[3],cb[4]; /**< c: coor of entrance/exit point, cb: bary coor of entrance/exit */
    int      kel,key; /**< kel: elt in which we travel, key: location of entrance or exit */
    int      np; /**< global indice of entrance point */
    char     tag; /**< tag of edge */

} _MMG5_Travel;
#endif

/* bucket */
_MMG5_pBucket newBucket(MMG5_pMesh ,int );
int     addBucket(MMG5_pMesh ,_MMG5_pBucket ,int );
int     delBucket(MMG5_pMesh ,_MMG5_pBucket ,int );
int buckin_iso(MMG5_pMesh mesh,MMG5_pSol sol,_MMG5_pBucket bucket,int ip);
/* prototypes */
void rotmatrix(double n[3],double r[3][3]);
double det3pt1vec(double c0[3],double c1[3],double c2[3],double v[3]);
double det4pt(double c0[3],double c1[3],double c2[3],double c3[3]);
double orvol(pPoint point,int *v);
int directsurfball(MMG5_pMesh mesh, int ip, int *list, int ilist, double n[3]);

int  newPt(MMG5_pMesh mesh,double c[3],char tag);
int  newElt(MMG5_pMesh mesh);
void delElt(MMG5_pMesh mesh,int iel);
void delPt(MMG5_pMesh mesh,int ip);
int  zaldy(MMG5_pMesh mesh);
void freeXTets(MMG5_pMesh mesh);
char _MMG5_chkedg(MMG5_pMesh mesh,MMG5_pTria pt,char ori);
int  chkNumberOfTri(MMG5_pMesh mesh);
void _MMG5_tet2tri(MMG5_pMesh mesh,int k,char ie,Tria *ptt);
int  bezierCP(MMG5_pMesh mesh,Tria *pt,_MMG5_pBezier pb,char ori);
int  BezierTgt(double c1[3],double c2[3],double n1[3],double n2[3],double t1[3],double t2[3]);
double BezierGeod(double c1[3], double c2[3], double t1[3], double t2[3]);
int  bezierInt(_MMG5_pBezier pb,double uv[2],double o[3],double no[3],double to[3]);
int  BezierReg(MMG5_pMesh mesh,int ip0, int ip1, double s, double v[3], double *o, double *no);
int  BezierRef(MMG5_pMesh mesh,int ip0, int ip1, double s, double *o, double *no, double *to);
int  BezierEdge(MMG5_pMesh mesh,int ip0, int ip1, double b0[3], double b1[3],char isrid, double v[3]);
int  BezierRidge(MMG5_pMesh mesh,int ip0, int ip1, double s, double *o, double *no1, double *no2, double *to);
int  BezierNom(MMG5_pMesh mesh,int ip0,int ip1,double s,double *o,double *no,double *to);
int  norface(MMG5_pMesh mesh ,int k, int iface, double v[3]);
int  boulen(MMG5_pMesh mesh,int start,int ip,double *nn);
int  bouler(MMG5_pMesh mesh,int start,int ip,int *list,int *ng,int *nr);
int  boulenm(MMG5_pMesh mesh, int start, int ip, int iface, double n[3],double t[3]);
int  boulec(MMG5_pMesh mesh,int start,int ip,double *tt);
int  boulevolp(MMG5_pMesh mesh, int start, int ip, int * list);
int  boulesurfvolp(MMG5_pMesh mesh,int start,int ip,int iface,int *listv,int *ilistv,int *lists,int*ilists);
int  startedgsurfball(MMG5_pMesh mesh,int nump,int numq,int *list,int ilist);
int  srcbdy(MMG5_pMesh mesh,int start,int ia);
int  coquil(MMG5_pMesh mesh, int start, int ia, int * list);
int  coquilface(MMG5_pMesh mesh, int start, int ia, int * list, int * it1, int *it2);
int  gettag(MMG5_pMesh,int,int,int *,int *);
int  settag(MMG5_pMesh,int,int,int,int);
int  chkcol_int(MMG5_pMesh ,MMG5_pSol met,int,char,char,int *,char typchk);
int  chkcol_bdy(MMG5_pMesh,int,char,char,int *);
int  chkmanicoll(MMG5_pMesh mesh,int k,int iface,int iedg,int ndepmin,int ndepplus,char isminp,char isplp);
int  chkmani(MMG5_pMesh mesh);
int  colver(MMG5_pMesh,int *,int,char);
int  analys(MMG5_pMesh mesh);
int  hashTetra(MMG5_pMesh mesh, int pack);
int  hashTria(MMG5_pMesh mesh);
int  hashEdge(MMG5_pMesh mesh,_MMG5_Hash *hash,int a,int b,int k);
int  hashGet(_MMG5_Hash *hash,int a,int b);
int  hashPop(_MMG5_Hash *hash,int a,int b);
int  hashNew(MMG5_pMesh mesh, _MMG5_Hash *hash,int hsiz,int hmax);
int  hPop(HGeom *hash,int a,int b,int *ref,char *tag);
int  hTag(HGeom *hash,int a,int b,int ref,char tag);
int  hGet(HGeom *hash,int a,int b,int *ref,char *tag);
void hEdge(MMG5_pMesh mesh,int a,int b,int ref,char tag);
int  hNew(HGeom *hash,int hsiz,int hmax,int secure);
int  hGeom(MMG5_pMesh mesh);
int  bdryTria(MMG5_pMesh );
int  bdryIso(MMG5_pMesh );
int  bdrySet(MMG5_pMesh );
int  bdryUpdate(MMG5_pMesh );
int  bdryPerm(MMG5_pMesh );
int  chkmsh(MMG5_pMesh,int,int);
int  chkfemtopo(MMG5_pMesh mesh);
int  cntbdypt(MMG5_pMesh mesh, int nump);
long long memSize(void);
void memOption(MMG5_pMesh mesh);
int  _MMG5_mmg3d1(MMG5_pMesh ,MMG5_pSol );
int  _MMG5_mmg3d1_delone(MMG5_pMesh ,MMG5_pSol );
int  _MMG5_mmg3d2(MMG5_pMesh ,MMG5_pSol );
int  split1_sim(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split1(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
int  split1b(MMG5_pMesh mesh,MMG5_pSol met,int *list,int ret,int ip,int cas);
int  split2sf_sim(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split2sf(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split2(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
int  split3_sim(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split3(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split3cone(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split3op(MMG5_pMesh mesh, MMG5_pSol met, int k, int vx[6]);
void split4sf(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split4op(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split5(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
void split6(MMG5_pMesh mesh,MMG5_pSol met,int k,int vx[6]);
int  split4bar(MMG5_pMesh mesh,MMG5_pSol met,int k);
int  simbulgept(MMG5_pMesh mesh, int *list, int ilist, double o[3]);
int  dichoto1b(MMG5_pMesh mesh,int *list,int ret,double o[3],double ro[3]);
void nsort(int ,double *,char *);
int  nortri(MMG5_pMesh mesh,MMG5_pTria pt,double *n);
double orcal(MMG5_pMesh mesh,int iel);
int  movintpt(MMG5_pMesh mesh, int *list, int ilist, int improve);
int  movbdyregpt(MMG5_pMesh mesh, int *listv, int ilistv, int *lists, int ilists);
int  movbdyrefpt(MMG5_pMesh mesh, int *listv, int ilistv, int *lists, int ilists);
int  movbdynompt(MMG5_pMesh mesh, int *listv, int ilistv, int *lists, int ilists);
int  movbdyridpt(MMG5_pMesh mesh, int *listv, int ilistv, int *lists, int ilists);
double caltri(MMG5_pMesh mesh,MMG5_pTria ptt);
int  scaleMesh(MMG5_pMesh mesh,MMG5_pSol met,pSingul sin);
int  unscaleMesh(MMG5_pMesh mesh,MMG5_pSol met);
int  chkswpbdy(MMG5_pMesh mesh,int *list,int ilist,int it1,int it2);
int  swpbdy(MMG5_pMesh mesh,MMG5_pSol met,int *list,int ret,int it1,_MMG5_pBucket bucket);
int  swpgen(MMG5_pMesh mesh,MMG5_pSol met,int nconf, int ilist, int *list,_MMG5_pBucket bucket);
int  chkswpgen(MMG5_pMesh mesh, int start, int ia, int *ilist, int *list,double crit);
int  srcface(MMG5_pMesh mesh,int n0,int n1,int n2);
int  bouleext(MMG5_pMesh mesh, int start, int ip, int iface, int *listv, int *ilistv, int *lists, int*ilists);
int chkptonbdy(MMG5_pMesh,int);
int norpts(MMG5_pMesh,int,int,int,double *);
double orcal_poi(double a[3],double b[3],double c[3],double d[3]);
int countelt(MMG5_pMesh mesh,MMG5_pSol sol, double *weightelt, long *npcible);
int trydisp(MMG5_pMesh,double *,short);
int dichodisp(MMG5_pMesh,double *);
int lapantilap(MMG5_pMesh,double *);
int ppgdisp(MMG5_pMesh,double *);
int denoisbdy(MMG5_pMesh);
int eigensym(double m[3],double lambda[2],double vp[2][2]);
int sys33sym(double a[6], double b[3], double r[3]);
void outqua(MMG5_pMesh mesh,MMG5_pSol met);
int  badelt(MMG5_pMesh mesh,MMG5_pSol met);
int prilen(MMG5_pMesh mesh,MMG5_pSol met);
int DoSol(MMG5_pMesh mesh,MMG5_pSol met);
/* useful functions to debug */
int  indElt(MMG5_pMesh mesh,int kel);
int  indPt(MMG5_pMesh mesh,int kp);
void printTria(MMG5_pMesh mesh,char* fileName);
void printTetra(MMG5_pMesh mesh,char* fileName);
int  _MMG5_saveAllMesh(MMG5_pMesh mesh);
int  _MMG5_saveLibraryMesh(MMG5_pMesh mesh);

#ifdef USE_SCOTCH
int _MMG5_renumbering(int vertBoxNbr, MMG5_pMesh mesh, MMG5_pSol sol);
#endif
int _MMG5_scotchCall(MMG5_pMesh mesh, MMG5_pSol sol);

#ifdef SINGUL
int  inserSingul(MMG5_pMesh mesh, MMG5_pSol met, pSingul singul);
int  creaEdge(MMG5_pMesh mesh, MMG5_pSol met, _MMG5_Travel *trav, char tag);
int  creaPoint(MMG5_pMesh mesh, MMG5_pSol met,int iel, double c[3], double cb[4], char tag);
int  colSing(MMG5_pMesh mesh,MMG5_pSol met);
int  seekEdge(MMG5_pMesh mesh, MMG5_pSol met, psPoint ppt0, psPoint ppt1,
              _MMG5_Travel *trav, int *lastet,int*,int*);
int  seekPoint(MMG5_pMesh mesh, psPoint ppt, double cb[4],int*,int*);
int  solveUnsignedTet(MMG5_pMesh mesh,MMG5_pSol met);
int  split3cb(MMG5_pMesh mesh, MMG5_pSol met, int k, int ifac, double o[3],double cb[4], int *ip);
int  split4cb(MMG5_pMesh mesh, MMG5_pSol met, int k, double o[3], double cb[4],int *ip);
int  swap23(MMG5_pMesh mesh,int k, int ip);
#endif

int meancur(MMG5_pMesh mesh,int np,double c[3],int ilist,int *list,double h[3]);
double surftri(MMG5_pMesh,int,int);
double timestepMCF(MMG5_pMesh,double);
int bdyMCF(MMG5_pMesh);
double volint(MMG5_pMesh);

/* Delaunay functions*/
int delone(MMG5_pMesh mesh,MMG5_pSol sol,int ip,int *list,int ilist);
int cavity(MMG5_pMesh mesh,MMG5_pSol sol,int iel,int ip,int *list,int lon);
int cenrad_iso(MMG5_pMesh mesh,double *ct,double *c,double *rad);

/*mmg3d1.c*/
void tet2tri(MMG5_pMesh mesh,int k,char ie,Tria *ptt);
int dichoto(MMG5_pMesh mesh,MMG5_pSol met,int k,int *vx);
/** Find acceptable position for split1b, passing the shell of considered edge, starting from o */
int dichoto1b(MMG5_pMesh mesh,int *list,int ret,double o[3],double ro[3]);
/** return edges of (virtual) triangle pt that need to be split w/r Hausdorff criterion */
char chkedg(MMG5_pMesh mesh,Tria *pt,char ori);
int anatet(MMG5_pMesh mesh,MMG5_pSol met,char typchk, int patternMode) ;
int movtet(MMG5_pMesh mesh,MMG5_pSol met,int maxitin);
int swpmsh(MMG5_pMesh mesh,MMG5_pSol met,_MMG5_pBucket bucket);
int swptet(MMG5_pMesh mesh,MMG5_pSol met,double crit,_MMG5_pBucket bucket);

/* pointers */
double caltet_ani(MMG5_pMesh mesh,MMG5_pSol met,int ia,int ib,int ic,int id);
double caltet_iso(MMG5_pMesh mesh,MMG5_pSol met,int ia,int ib,int ic,int id);
double lenedg_ani(MMG5_pMesh ,MMG5_pSol ,int ,int );
double lenedg_iso(MMG5_pMesh ,MMG5_pSol ,int ,int );
double lenedgCoor_ani(double*, double*, double*, double*);
double lenedgCoor_iso(double*, double*, double*, double*);
int    defsiz_iso(MMG5_pMesh,MMG5_pSol );
int    defsiz_ani(MMG5_pMesh ,MMG5_pSol );
int    gradsiz_iso(MMG5_pMesh ,MMG5_pSol );
int    gradsiz_ani(MMG5_pMesh ,MMG5_pSol );

double (*caltet)(MMG5_pMesh mesh,MMG5_pSol met,int ia,int ib,int ic,int id);
int    (*defsiz)(MMG5_pMesh ,MMG5_pSol );
double (*lenedg)(MMG5_pMesh mesh,MMG5_pSol sol ,int ,int );
int    (*gradsiz)(MMG5_pMesh ,MMG5_pSol );

#endif
