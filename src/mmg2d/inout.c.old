/* =============================================================================
**  This file is part of the mmg software package for the tetrahedral
**  mesh modification.
**  Copyright (c) Inria - IMB (Universit√© de Bordeaux) - LJLL (UPMC), 2004- .
**
**  mmg is free software: you can redistribute it and/or modify it
**  under the terms of the GNU Lesser General Public License as published
**  by the Free Software Foundation, either version 3 of the License, or
**  (at your option) any later version.
**
**  mmg is distributed in the hope that it will be useful, but WITHOUT
**  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
**  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
**  License for more details.
**
**  You should have received a copy of the GNU Lesser General Public
**  License and of the GNU General Public License along with mmg (in
**  files COPYING.LESSER and COPYING). If not, see
**  <http://www.gnu.org/licenses/>. Please read their terms carefully and
**  use this copy of the mmg distribution only if you accept them.
** =============================================================================
*/
#include "mmg2d.h"


/* read mesh data */
int MMG2_loadMesh(pMesh mesh,char *filename) {
  pPoint       ppt; 
  pEdge        ped;
  pTria        pt;
  float        fp1,fp2; 
	double				dp1,dp2;
  int          k,inm,ref,tmp,nc,num,norient;
  char        *ptr,data[128];
  double       air;       
	int					 nr,isr,i;
  strcpy(data,filename);
  ptr = strstr(data,".mesh");
  if ( !ptr ) {
    strcat(data,".meshb");
    if (!(inm = GmfOpenMesh(data,GmfRead,&mesh->ver,&mesh->dim)) ) {
      ptr  = strstr(data,".mesh");
      *ptr = '\0';
      strcat(data,".mesh");
      if (!(inm = GmfOpenMesh(data,GmfRead,&mesh->ver,&mesh->dim)) ) {
        fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
        return(0);
      }
    }
  }
  else if (!(inm = GmfOpenMesh(data,GmfRead,&mesh->ver,&mesh->dim)) ) {
    fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
    return(0);
  }

  if( (mesh->info.imprim < 0) && (mesh->ver == GmfDouble) ) {
    fprintf(stdout,"  ** Double precision\n");
    //return(0);
  }

  fprintf(stdout,"  %%%% %s OPENED\n",data);

  if ( abs(mesh->info.imprim) > 3 )
    fprintf(stdout,"  -- READING DATA FILE %s\n",data);


  mesh->npfixe  = GmfStatKwd(inm,GmfVertices);
  mesh->nedfixe = GmfStatKwd(inm,GmfEdges);
  mesh->ntfixe  = GmfStatKwd(inm,GmfTriangles);

  if ( !mesh->npfixe ) {
    fprintf(stdout,"  ** MISSING DATA\n");
    return(0);
  } else if (!mesh->ntfixe){
    assert(abs(mesh->info.option)==2);   
  }
  mesh->np  = mesh->npfixe;
  mesh->ned = mesh->nedfixe;
  mesh->nt  = mesh->ntfixe;

  /* mem alloc */
  //   if ( !MMG2_zaldy(mesh) )  return(0);

  /* read vertices */
  GmfGotoKwd(inm,GmfVertices);  
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( mesh->ver == GmfFloat ) {
      GmfGetLin(inm,GmfVertices,&fp1,&fp2,&ref);      			
      ppt->c[0] = fp1;
      ppt->c[1] = fp2;
    }
    else
      GmfGetLin(inm,GmfVertices,&ppt->c[0],&ppt->c[1],&ref);  
    ppt->ref = ref;   
		// 	  if(ref!=0)
		//  	ppt->tag &= ~M_NUL;
		// else
      ppt->tag = M_NUL; 
  }

  /* read edges */        
  GmfGotoKwd(inm,GmfEdges);
  for (k=1; k<=mesh->ned; k++) {
    ped = &mesh->edge[k];
    GmfGetLin(inm,GmfEdges,&ped->v[0],&ped->v[1],&ref);
    ped->ref  = ref;     
  } 
// // //HACK pour sauver les edges et les points dessus
//   // GmfGotoKwd(inm,GmfRidges);
//   // nr = GmfStatKwd(inm,GmfRidges);
//   // for (k=1; k<=nr; k++) {
//   //   GmfGetLin(inm,GmfRidges,&isr);
//   //   ped = &mesh->edge[isr];
//   //   ped->ref  = -1;     
//   // } 
//   // GmfCloseMesh(inm);  
//   for (k=1; k<=mesh->ned; k++) {
//     ped = &mesh->edge[k];
// 		// if(ped->ref!=-1) {
// 		// 	ped->v[0] = 0;
// 		// 	continue;
// 		// }
//     mesh->point[ped->v[0]].tag &= ~M_NUL;
//     mesh->point[ped->v[1]].tag &= ~M_NUL;
//   }  
// 	MMG2_saveMesh(mesh,"bdry.mesh");
// 	exit(0); 
// ///FIN HACK pour edge	 
//HACK pour sauver que les bords
  //GmfCloseMesh(inm);
	// inm = GmfOpenMesh("L1T2ok.mesh",GmfRead,&mesh->ver,&mesh->dim);
	//   mesh->npfixe  += GmfStatKwd(inm,GmfVertices);
	//   mesh->nedfixe += GmfStatKwd(inm,GmfEdges);   
	// printf("on a rajoute %d points et %d edges\n",mesh->npfixe-mesh->np,mesh->nedfixe-mesh->ned);
	//   GmfGotoKwd(inm,GmfVertices);  
	// i=1;
	//   for (k=mesh->np+1; k<=mesh->npfixe; k++) {
	//     ppt = &mesh->point[k];
	//     if ( mesh->ver == GmfFloat ) {
	//       GmfGetLin(inm,GmfVertices,&fp1,&fp2,&ref);      			
	//       ppt->c[0] = fp1;
	//       ppt->c[1] = fp2;
	//     }
	//     else
	//       GmfGetLin(inm,GmfVertices,&ppt->c[0],&ppt->c[1],&ref);  
	//     ppt->ref = ref;   
	//     ppt->tag = M_NUL;
	//   }
	//   /* read required vertices*/     
	//   GmfGotoKwd(inm,GmfRequiredVertices); 
	//   nc  = GmfStatKwd(inm,GmfRequiredVertices);   
	//   for (k=1; k<=nc; k++) {
	//     GmfGetLin(inm,GmfRequiredVertices,&num);
	//     ppt = &mesh->point[num+mesh->np];
	//     ppt->tag |= M_REQUIRED;    
	//     ppt->tag &= ~M_NUL;
	//   }
	//   GmfGotoKwd(inm,GmfEdges);
	//   for (k=mesh->ned+1; k<=mesh->nedfixe; k++) {
	//     ped = &mesh->edge[k];
	//     GmfGetLin(inm,GmfEdges,&ped->v[0],&ped->v[1],&ref); 
	// 	ped->v[0] +=mesh->np;
	// 	ped->v[1] +=mesh->np;
	//     ped->ref  = ref;     
	//   }
	//   GmfCloseMesh(inm);
	// mesh->np = mesh->npfixe;
	// mesh->ned = mesh->nedfixe;
	// MMG2_saveMesh(mesh,"ouf.mesh");
	// exit(0); 
  /* read triangles */  
	if(mesh->nt) {
   GmfGotoKwd(inm,GmfTriangles); 
   norient = 0;
   for (k=1; k<=mesh->nt; k++) {
     pt = &mesh->tria[k];
     GmfGetLin(inm,GmfTriangles,&pt->v[0],&pt->v[1],&pt->v[2],&ref);
     pt->ref  = ref & 0x7fff;
     air = MMG2_quickarea(mesh->point[pt->v[0]].c,mesh->point[pt->v[1]].c,
                          mesh->point[pt->v[2]].c);
     if(air < 0) {
       printf("Tr %d bad oriented\n",k);
         norient++;
       tmp = pt->v[2];
       pt->v[2] = pt->v[1];
       pt->v[1] = tmp;
     } 
   }
   fprintf(stdout," %8d triangles reoriented \n",norient); 
  }
  /* read corners*/     
  nc  = GmfStatKwd(inm,GmfCorners);   
  GmfGotoKwd(inm,GmfCorners); 
  for (k=1; k<=nc; k++) {
    GmfGetLin(inm,GmfCorners,&num);
    ppt = &mesh->point[num];
    ppt->tag |= M_CORNER;
  }
  /* read required vertices*/     
  GmfGotoKwd(inm,GmfRequiredVertices); 
  nc  = GmfStatKwd(inm,GmfRequiredVertices);   
  for (k=1; k<=nc; k++) {
    GmfGetLin(inm,GmfRequiredVertices,&num);
    ppt = &mesh->point[num];
    ppt->tag |= M_REQUIRED;
  }
    
  /* read required edges*/
  GmfGotoKwd(inm,GmfRequiredEdges); 
  nc  = GmfStatKwd(inm,GmfRequiredEdges);
  for (k=1; k<=nc; k++) {
    GmfGetLin(inm,GmfRequiredEdges,&num);
    ped = &mesh->edge[num];
    ped->tag |= M_REQUIRED;
    ppt = &mesh->point[ped->v[0]];
    ppt->tag |= M_REQUIRED;
    ppt = &mesh->point[ped->v[1]];
    ppt->tag |= M_REQUIRED;
  }
  GmfCloseMesh(inm);   
// // //HACK RAE : concat 2 mesh
	// inm = GmfOpenMesh("interieur.d.mesh",GmfRead,&mesh->ver,&mesh->dim);
	//   mesh->npfixe  += GmfStatKwd(inm,GmfVertices);
	//   mesh->ntfixe += GmfStatKwd(inm,GmfTriangles);   
	// printf("on a rajoute %d points et %d tria\n",mesh->npfixe-mesh->np,mesh->ntfixe-mesh->nt);
	//   GmfGotoKwd(inm,GmfVertices);  
	// 	i = mesh->np+1;
	//   for (k=mesh->np+1; k<=mesh->npfixe; k++) { 
	// 		if(0 && k<mesh->np+709) {
	// 			if ( mesh->ver == GmfFloat ) 
	//         GmfGetLin(inm,GmfVertices,&fp1,&fp2,&ref);
	//      	else 
	// 		    GmfGetLin(inm,GmfVertices,&dp1,&dp2,&ref);
	//  
	//       continue;                                 
	//     }
	//     ppt = &mesh->point[i++]; 
	//     if ( mesh->ver == GmfFloat ) {
	//       GmfGetLin(inm,GmfVertices,&fp1,&fp2,&ref);      			
	//       ppt->c[0] = fp1;
	//       ppt->c[1] = fp2;
	//     }
	//     else
	//       GmfGetLin(inm,GmfVertices,&ppt->c[0],&ppt->c[1],&ref);  
	//     ppt->ref = ref;   
	//     ppt->tag = M_NUL;
	//   }  
	// 	for(k=i;k<=mesh->npfixe;k++)
	// 		(mesh->point[k]).tag = M_NUL;
	// 	for(k=i;k<=mesh->ned;k++)
	// 		(mesh->edge[k]).tag = M_NUL;
	// 		
	//    GmfGotoKwd(inm,GmfTriangles);  
	//   for (k=mesh->nt+1; k<=mesh->ntfixe; k++) {
	//     pt = &mesh->tria[k];
	//  	    GmfGetLin(inm,GmfTriangles,&pt->v[0],&pt->v[1],&pt->v[2],&ref);  
	//     pt->ref = 300; 
	//   	// if(pt->v[0] < 64 && pt->v[0] > 32) {  
	//   	// 				if(pt->v[0]==33) pt->v[0] = 380;
	//   	// 				else if(pt->v[0]==34) pt->v[0] = 385;
	//   	// 				else
	//   	// 				  pt->v[0] = 385 + 4*(pt->v[0]-34) ;
	//   	// } else if(pt->v[0]>33)
	//   	//   pt->v[0] = mesh->np + (pt->v[0] );
	//   	// if(pt->v[1] < 64 && pt->v[1] > 32) {  
	//   	// 				if(pt->v[1]==33) pt->v[1] = 380;
	//   	// 				else if(pt->v[1]==34) pt->v[1] = 385;
	//   	// 				else
	//   	// 				  pt->v[1] = 385 + 4*(pt->v[1]-34) ;
	//   	// } else if(pt->v[1]>33) 
	//   	//   pt->v[1] = mesh->np + (pt->v[1] ); 
	//   	// if(pt->v[2] < 64 && pt->v[2] > 32) {  
	//   	// 				if(pt->v[2]==33) pt->v[2] = 380;
	//   	// 				else if(pt->v[2]==34) pt->v[2] = 385;
	//   	// 				else if(pt->v[2]>33)
	//   	// 				  pt->v[2] = 385 + 4*(pt->v[2]-34) ;
	//   	// } else 
	//   	//   pt->v[2] = mesh->np + (pt->v[2] );
	//     //RAE
	//   	// if(pt->v[0] < 449) {
	//   	// 				pt->v[0] = 514 + 2*(pt->v[0]-1) ;
	//   	// } else 
	//   	//   pt->v[0] = mesh->np + (pt->v[0] - 448);
	//   	// if(pt->v[1] < 449) {
	//   	// 				pt->v[1] = 514 + 2*(pt->v[1]-1);
	//   	// } else 
	//   	//   pt->v[1] = mesh->np + (pt->v[1] - 448); 
	//   	// if(pt->v[2] < 449) {
	//   	// 				pt->v[2] = 514 + 2*(pt->v[2]-1);
	//   	// } else 
	//   	//   pt->v[2] = mesh->np + (pt->v[2] - 448);      
	//     //ENDRAE
	// 		// pt->v[0] += mesh->np;
	// 		// pt->v[1] += mesh->np;
	// 		// pt->v[2] += mesh->np;
	//   } 
	// 
	//  	  GmfCloseMesh(inm);
	// 	mesh->np = mesh->npfixe;// - 448;
	//   mesh->nt = mesh->ntfixe;  
	//     for (k=1; k<=mesh->nt; k++) {
	//       pt = &mesh->tria[k];
	//       if ( !M_EOK(pt) )  continue;
	//       for (i=0; i<3; i++) {
	//         ppt = &mesh->point[ pt->v[i] ];
	//         ppt->tag &= ~M_NUL;
	//       }
	//     }       	
	// MMG2_saveMesh(mesh,"ouf.mesh");
	// exit(0);  
// // 	//end HACK RAE 
  /*maill periodique : remettre toutes les coord entre 0 et 1*/
  if(mesh->info.per) { 
      printf("on passe la , on a %d points %d triangles\n",mesh->np,mesh->nt);
    for (k=1; k<=mesh->np; k++) {
      ppt = &mesh->point[k];  
      while (ppt->c[0] > 1 + 5e-3) {
        ppt->c[0] -= 1;  
      } 
      while (ppt->c[0] < 0 - 5e-3) {
        ppt->c[0] += 1;  
      }
      while (ppt->c[1] > 1 + 5e-3) {
          ppt->c[1] -= 1;            
      } 
      while (ppt->c[1] < 0 - 5e-3) {
          ppt->c[1] += 1;  
      }
    }
  }  

  return(1);
}
  

/* load metric */
int MMG2_loadSol(pSol sol,char *filename,int npmax) {
  double       dbuf[ GmfMaxTyp ];
  float        fbuf[ GmfMaxTyp ];
  int          i,k,inm,iadr;
  char        *ptr,data[128];

  strcpy(data,filename);
  ptr = strstr(data,".mesh");
  if ( ptr )  *ptr = '\0';
  strcat(data,".solb");
  if (!(inm = GmfOpenMesh(data,GmfRead,&sol->ver,&sol->dim)) ) {
    ptr  = strstr(data,".sol");
    *ptr = '\0';
    strcat(data,".sol");
    if (!(inm = GmfOpenMesh(data,GmfRead,&sol->ver,&sol->dim)) ) {
      fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
      return(0);
    }
  }
  fprintf(stdout,"  %%%% %s OPENED\n",data);
  fprintf(stdout,"  -- READING METRIC FILE %s\n",data);

  sol->np = GmfStatKwd(inm,GmfSolAtVertices,&sol->type,&sol->size,sol->typtab);   
  //printf("on trouve %d %d %d\n",sol->type, sol->size,sol->typtab[0]);
  if ( !sol->np ) {
    fprintf(stdout,"  ** MISSING DATA.\n");
    return(0);
  }
  if ( (sol->typtab[0] != 1) && (sol->typtab[0] != 3) ) {
    fprintf(stdout,"  ** WRONG DATA TYPE IGNORED.\n"); 
    sol->size = 1;
    sol->np   = 0;
    return(0);
  }
  if (sol->type!=1) {
    fprintf(stdout,"  #### WARNING SEVERAL DATA READ. IGNORED\n");
    sol->size = 1;
    sol->np   = 0;
    return(0);    
  }
  /* mem alloc */
  sol->met = (double*)M_calloc((sol->size*npmax)+1,sizeof(double),"inout");
  assert(sol->met);

  /* read mesh solutions */
  GmfGotoKwd(inm,GmfSolAtVertices);
  for (k=1; k<=sol->np; k++) {
    if ( sol->ver == GmfFloat ) {
      GmfGetLin(inm,GmfSolAtVertices,fbuf);
      iadr = (k-1)*sol->size + 1;
      for (i=0; i<sol->size; i++)
        sol->met[iadr+i] = fbuf[i];
    }
    else {
      GmfGetLin(inm,GmfSolAtVertices,dbuf);
      iadr = (k-1)*sol->size + 1;
      for (i=0; i<sol->size; i++)
        sol->met[iadr+i] = dbuf[i];  
    }
  }

  GmfCloseMesh(inm);
  return(1);  
}


/* save mesh to disk */
int MMG2_saveMesh(pMesh mesh,char *filename) { 
	FILE*					inm;
  pPoint       ppt;   
  pEdge        ped;
  pTria        pt;
  float        fp1,fp2;
  int          k,outm,ne,ref,j;
  char        *ptr,data[128],chaine[128];

	mesh->ver = GmfDouble;
  strcpy(data,filename);
  ptr = strstr(data,".mesh");  
  if ( !ptr ) {
    strcat(data,".meshb");
    *ptr = '\0';
    strcat(data,".mesh"); 
  }
	if( !(inm = fopen(data,"w")) ) {
    fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
    return(0);
  }
  strcpy(&chaine[0],"MeshVersionFormatted 2\n"); 
  fprintf(inm,"%s",chaine);
  strcpy(&chaine[0],"\n\nDimension 2\n"); 
  fprintf(inm,"%s ",chaine);

  // if ( !ptr ) {
  //   strcat(data,".meshb");
  //   if ( !(outm = GmfOpenMesh(data,GmfWrite,mesh->ver,mesh->dim)) ) {
  //     ptr  = strstr(data,".mesh");
  //     *ptr = '\0';
  //     strcat(data,".mesh");
  //     if ( !(outm = GmfOpenMesh(data,GmfWrite,mesh->ver,mesh->dim)) ) {
  //       fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
  //       return(0);
  //     }
  //   }
  // }
  // else if ( !(outm = GmfOpenMesh(data,GmfWrite,mesh->ver,mesh->dim)) ) {
  //   fprintf(stderr,"  ** UNABLE TO OPEN %s.\n",data);
  //   return(0);
  // }
  fprintf(stdout,"  %%%% %s OPENED\n",data);
  
	// //HACK SAVE ONLY SD ref 2
	//   for (k=1; k<=mesh->np; k++) {
	//     ppt = &mesh->point[k];  
	//     ppt->tag = M_NUL; 
	//   }
	//   for (k=1; k<=mesh->nt; k++) {
	//     pt = &mesh->tria[k];  
	// 	if (!M_EOK(pt)) continue;
	//     if (pt->ref==2) { 
	// 		mesh->point[pt->v[0]].tag &= ~M_NUL;
	// 		mesh->point[pt->v[1]].tag &= ~M_NUL;
	// 		mesh->point[pt->v[2]].tag &= ~M_NUL;
	//     } else {
	// 		pt->v[0] = 0;
	//     }
	//   }
	//   for (k=1; k<=mesh->ned; k++) {
	//     ped = &mesh->edge[k];  
	//   	if(!ped->v[0]) continue;  
	//     ppt = &mesh->point[ped->v[0]];  
	//   	if(!M_VOK(ppt)) {
	//   		ped->v[0] = 0;
	//   		continue;
	//   	}
	//     ppt = &mesh->point[ped->v[1]];  
	//   	if(!M_VOK(ppt)) {
	//   		ped->v[0] = 0;
	//   		continue;
	//   	} 
	//   	ped->tag |= M_REQUIRED;
	//    } 
	//   	
	// //END HACK
	
  /* vertices */ 
  ne = 0;
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];  
    if ( M_VOK(ppt) )  ne++; 
    ppt->tas = ne;
  }
  strcpy(&chaine[0],"\n\nVertices\n"); 
  fprintf(inm,"%s",chaine);
  fprintf(inm,"%d\n",ne);  
  //GmfSetKwd(outm,GmfVertices,ne);
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( M_VOK(ppt) ) {
      ref = ppt->ref;   
      if ( mesh->ver == GmfFloat ) {
        fp1 = ppt->c[0];
        fp2 = ppt->c[1];
	      ref = ppt->ref;           
				fprintf(inm,"%e %e %d\n",fp1,fp2,ref);
   	    //GmfSetLin(outm,GmfVertices,fp1,fp2,ref);
      }
      else {  
        ref = ppt->ref;   
				fprintf(inm,"%e %e %d\n",ppt->c[0],ppt->c[1],ref);
        //GmfSetLin(outm,GmfVertices,ppt->c[0],ppt->c[1],ref);
      }
    }
  }
  /* corners */
  ne = 0;
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];         
    if ( M_VOK(ppt) && (ppt->tag & M_CORNER) /*&& (ppt->tag & M_BDRY)*/)  ne++;
  }         
  strcpy(&chaine[0],"\n\nCorners\n"); 
  fprintf(inm,"%s",chaine);
  fprintf(inm,"%d\n",ne);  
  //GmfSetKwd(outm,GmfCorners,ne);
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( M_VOK(ppt) && (ppt->tag & M_CORNER) /*&& (ppt->tag & M_BDRY)*/) {
        //GmfSetLin(outm,GmfCorners,ppt->tas);  
        fprintf(inm,"%d\n",ppt->tas);
    }
  }
  /* required vertex */
  ne = 0;
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( M_VOK(ppt) && (ppt->tag & M_REQUIRED))  ne++;
  }
  //GmfSetKwd(outm,GmfRequiredVertices,ne);
  strcpy(&chaine[0],"\n\nRequiredVertices\n"); 
  fprintf(inm,"%s",chaine);
  fprintf(inm,"%d\n",ne);  
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( M_VOK(ppt) && (ppt->tag & M_REQUIRED) && (ppt->tag & M_BDRY)) {
        //GmfSetLin(outm,GmfRequiredVertices,ppt->tas); 
        fprintf(inm,"%d\n",ppt->tas);     
    }
  }

  
  if (!mesh->ned) {
    printf("NO EDGES\n");
    for (k=1; k<=mesh->nt; k++) {
      pt = &mesh->tria[k];
      if (!pt->v[0]) continue;
      for (j=0 ; j<3 ; j++) {
        if (!(&mesh->adja[3*(k-1)+1])[j]) {
          mesh->ned++;
          ped = &mesh->edge[mesh->ned];
          ped->v[0] = pt->v[MMG2_iare[j][0]];
          ped->v[1] = pt->v[MMG2_iare[j][1]];
          ped->ref  = M_MIN(mesh->point[pt->v[MMG2_iare[j][0]]].ref,
            mesh->point[pt->v[MMG2_iare[j][1]]].ref);
        }
      }
    }
  }

  /* edges */
  ne = 0;
  for (k=1; k<=mesh->ned; k++) {
    ped = &mesh->edge[k];  
		if(!ped->v[0]) continue;
		ne++;
   } 
  //GmfSetKwd(outm,GmfEdges,ne);
  strcpy(&chaine[0],"\n\nEdges\n"); 
  fprintf(inm,"%s",chaine);
  fprintf(inm,"%d\n",ne);  
  for (k=1; k<=mesh->ned; k++) {
    ped = &mesh->edge[k];  
		if(!ped->v[0]) continue;
    ref = ped->ref;  
    //GmfSetLin(outm,GmfEdges,mesh->point[ped->v[0]].tas,mesh->point[ped->v[1]].tas,ref);
    fprintf(inm,"%d %d %d\n",mesh->point[ped->v[0]].tas,mesh->point[ped->v[1]].tas,ref);
  }
  /* required edges */
  ne = 0;
  for (k=1; k<=mesh->ned; k++) {
    ped = &mesh->edge[k];
    if ( ped->v[0] && (ped->tag & M_REQUIRED))  ne++;
  }
  //GmfSetKwd(outm,GmfRequiredEdges,ne);
  strcpy(&chaine[0],"\n\nRequiredEdges\n"); 
  fprintf(inm,"%s",chaine);
  fprintf(inm,"%d\n",ne);  
	ne = 0;
  for (k=1; k<=mesh->ned; k++) {
    ped = &mesh->edge[k];
    if ( ped->v[0] && (ped->tag & M_REQUIRED)) {
        //GmfSetLin(outm,GmfRequiredEdges,k);      
      fprintf(inm,"%d\n",++ne);     
    }
  }
  /* elements */
  ne = 0;
  for (k=1; k<=mesh->nt; k++) {
    pt = &mesh->tria[k]; 
    //if(!((&mesh->adja[3*(k-1)+1])[0]) && !((&mesh->adja[3*(k-1)+1])[1]) && !((&mesh->adja[3*(k-1)+1])[2])) continue;
    if ( M_EOK(pt) )  ne++;
  }
  //GmfSetKwd(outm,GmfTriangles,ne);
  strcpy(&chaine[0],"\n\nTriangles\n"); 
  fprintf(inm,"%s",chaine);
  fprintf(inm,"%d\n",ne);  
  for (k=1; k<=mesh->nt; k++) {
    pt = &mesh->tria[k];
    //		if(!(&mesh->adja[3*(k-1)+1])[0] && !(&mesh->adja[3*(k-1)+1])[1] && !(&mesh->adja[3*(k-1)+1])[2]) continue;
    if ( M_EOK(pt) ) {
      ref = pt->ref;
      // GmfSetLin(outm,GmfTriangles,mesh->point[pt->v[0]].tas,
      //                             mesh->point[pt->v[1]].tas,
      //                             mesh->point[pt->v[2]].tas,ref);
			fprintf(inm,"%d %d %d %d\n",mesh->point[pt->v[0]].tas,
                                   mesh->point[pt->v[1]].tas,
                                   mesh->point[pt->v[2]].tas,ref);     
    }
  }
  strcpy(&chaine[0],"\n\nEnd\n"); 
  fprintf(inm,"%s",chaine);
	fclose(inm);
  //GmfCloseMesh(outm);
  return(1);
}
 

int MMG2_loadVect(pMesh mesh,char *filename) {
  Displ        pd;
  float        buf[GmfMaxTyp];
  double       dbuf[GmfMaxTyp];
  int          i,k,iadr,size,type,typtab[GmfMaxTyp],inm,dim;
  char        *ptr,data[128];

  pd = mesh->disp;

  strcpy(data,filename);
  ptr = strstr(data,".mesh");
  if ( ptr )  *ptr = '\0';
  strcat(data,".solb");
  if( !(inm = GmfOpenMesh(data, GmfRead, &pd.ver,&dim)) ) {
    ptr  = strstr(data,".solb");
    *ptr = '\0';
    strcat(data,".sol");
    if( !(inm = GmfOpenMesh(data, GmfRead, &pd.ver,&dim)) ) {
      fprintf(stderr,"  ** %s  NOT FOUND.\n",data);
      return(1);
    }
  }
  fprintf(stdout,"  %%%% %s OPENED\n",data);

  pd.np = GmfStatKwd(inm,GmfSolAtVertices,&type,&size,typtab);
  if ( !pd.np ) {
    fprintf(stdout,"  ** MISSING DATA\n");
    return(0);
  }
  else if ( pd.np != mesh->np ) {
    fprintf(stdout,"  ** WRONG DATA\n");
    return(0);
  }

  if ( typtab[0] != 2 ) {
    fprintf(stdout,"  ** DISPLACEMENT DATA IGNORED\n");
    return(0);
  }

  if ( abs(mesh->info.imprim) > 3 )
    fprintf(stdout,"  -- READING DISPLACEMENT FILE %s\n",data);

  /* read mesh solutions */
  GmfGotoKwd(inm,GmfSolAtVertices);
  for (k=1; k<=pd.np; k++) {
    iadr = (k - 1) * size + 1;
    if (pd.ver == GmfFloat) {
	  GmfGetLin(inm,GmfSolAtVertices,buf);
      for (i=0; i<size; i++)
        pd.mv[iadr + i] = buf[i];
    } else {
	  GmfGetLin(inm,GmfSolAtVertices,dbuf);
      for (i=0; i<size; i++)
        pd.mv[iadr + i] = dbuf[i];
    }

  }
 
  //if ( abs(mesh->info.imprim) > 3 )
    fprintf(stdout,"     NUMBER OF GIVEN DATA       %8d\n",pd.np);

  GmfCloseMesh(inm);
  return(1);
}
int MMG2_saveSol(pMesh mesh,pSol sol,char *filename) {
  pPoint       ppt;
  double	   bufd[GmfMaxTyp];
  float		   buff[GmfMaxTyp];
  int          k,i,isol,nbl,typtab[GmfMaxTyp],inm;
  char        *ptr,data[128],bin;
  if ( !sol->np )  return(1);
  bin = 1;
  strcpy(data,filename);
  ptr = strstr(data,".meshb");
  if ( ptr )  *ptr = '\0';
  else {
    ptr = strstr(data,".mesh");
    if ( ptr ) {
      *ptr = '\0';
      bin  = 0;
    }
  }
  if ( bin ) 
    strcat(data,".sol");
  else
    strcat(data,".sol");
  
  if(!sol->ver) sol->ver = 2;
  mesh->dim = 2;
  if( !(inm = GmfOpenMesh(data, GmfWrite, sol->ver,mesh->dim))  ) {
    fprintf(stderr,"  ** UNABLE TO OPEN %s. %d\n",data,sol->ver);
    return(0);
  }
  else
    fprintf(stdout,"  %%%% %s OPENED\n",data);
  switch(sol->size) {
  case 1:
  typtab[0] = GmfSca;
    break;
  case 3:
  typtab[0] = GmfSymMat;
    break;
  default:
    fprintf(stdout,"  ** DATA IGNORED\n");
    return(0);
  }
  
  /* write data */
  nbl = 0;
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( !M_VOK(ppt) )  continue;
    nbl++;
  }
  GmfSetKwd(inm,GmfSolAtVertices,nbl,1,typtab);
  
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( !M_VOK(ppt) )  continue;
    isol = (k-1) * sol->size + 1; 
    if (sol->ver == GmfFloat) {
      for (i=0; i<sol->size; i++)
        buff[i] = (float) sol->met[isol + i];
      GmfSetLin(inm,GmfSolAtVertices,buff);
    } else { 
      for (i=0; i<sol->size; i++)
        bufd[i] = sol->met[isol + i];
  
      GmfSetLin(inm,GmfSolAtVertices,bufd);
    }
  }
  
  GmfCloseMesh(inm);
  return(1);
}    

int MMG2_saveVect(pMesh mesh,pSol sol,char *filename,double lambda) {
  pPoint       ppt;
  Displ    pd;
  double	     bufd[GmfMaxTyp],lreal;
  float		     buff[GmfMaxTyp];         
  int          k,i,isol,nbl,typtab[GmfMaxTyp],inm,inm2;
  char        *ptr,data[128],data2[128],bin; 
	FILE *f;
  
  if(lambda > 1) {
  	lreal = 1.;
  } else {
  	lreal = lambda;
  }
  /*ecriture du lambda dans un fichier*/   
	f = fopen("lambda.dat","w");
	fprintf(f,"%10.12f\n",lambda);
	fclose(f);
	pd = mesh->disp;
  bin = 0;
  strcpy(data,filename);
  strcpy(data2,filename);
  ptr = strstr(data,".meshb");
  if ( ptr )  *ptr = '\0';
  else {
    ptr = strstr(data,".mesh");
    if ( ptr ) {
      *ptr = '\0';
      bin  = 0;
    }
  }
  strcat(data,"-lambda.sol");
  ptr = strstr(data2,".meshb");
  if ( ptr )  *ptr = '\0';
  else {
    ptr = strstr(data2,".mesh");
    if ( ptr ) {
      *ptr = '\0';
      bin  = 0;
    }
  }
  strcat(data2,"-1-lambda.sol");
  
  if( !(inm = GmfOpenMesh(data, GmfWrite, 2,2))  ) {
    fprintf(stderr,"  ** UNABLE TO OPEN %s. %d\n",data,sol->ver);
    return(0);
  }
  else
    fprintf(stdout,"  %%%% %s OPENED\n",data);
  if( !(inm2 = GmfOpenMesh(data2, GmfWrite, 2,2))  ) {
    fprintf(stderr,"  ** UNABLE TO OPEN %s. %d\n",data,sol->ver);
    return(0);
  }
  else
    fprintf(stdout,"  %%%% %s OPENED\n",data2);

  typtab[0] = GmfVec;
  
  /* write data */
  nbl = 0;
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( !M_VOK(ppt) )  continue;
    nbl++;
  }
  GmfSetKwd(inm,GmfSolAtVertices,nbl,1,typtab);
  GmfSetKwd(inm2,GmfSolAtVertices,nbl,1,typtab);
  
  for (k=1; k<=mesh->np; k++) {
    ppt = &mesh->point[k];
    if ( !M_VOK(ppt) )  continue;  
    for (i=0; i<2; i++)
      bufd[i] = lreal*pd.mv[2*(k-1) + 1 + i];
  
    GmfSetLin(inm,GmfSolAtVertices,bufd);
    for (i=0; i<2; i++)
      bufd[i] = (1.-lreal)*pd.mv[2*(k-1) + 1 + i];
  
    GmfSetLin(inm2,GmfSolAtVertices,bufd);
    
  } 
  
  GmfCloseMesh(inm);
  return(1);
}
